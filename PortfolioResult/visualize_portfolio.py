#!/usr/bin/env python3
"""
Portfolio Optimization Results Visualization Tool

This script creates comprehensive visualizations for portfolio optimization results,
including:
- Portfolio statistics comparison
- Monthly performance analysis
- Strategy allocation visualization
- Risk-return scatter plots
- Equity curve analysis
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import argparse
import os
from pathlib import Path
import sys

# Set style
sns.set_style("whitegrid")
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['font.size'] = 10


class PortfolioVisualizer:
    """Visualize portfolio optimization results"""
    
    def __init__(self, output_dir):
        """
        Initialize visualizer with output directory
        
        Args:
            output_dir: Path to optimizer output directory
        """
        self.output_dir = Path(output_dir)
        self.data = {}
        self._load_data()
    
    def _load_data(self):
        """Load all available CSV files from the output directory"""
        print(f"Loading data from: {self.output_dir}")
        
        # Define expected files - try both timestamped and non-timestamped versions
        file_mappings = {
            'best_portfolio': ['best_portfolio.csv'],
            'monthly_report': ['portfolioMonthlyReport_adjusted.csv', 'portfolioMonthlyReport_adjusted_*.csv'],
            'weekly_report': ['portfolioWeeklyReport_adjusted.csv', 'portfolioWeeklyReport_adjusted_*.csv'],
            'daily_report': ['portfolioDailyReport_adjusted.csv', 'portfolioDailyReport_adjusted_*.csv'],
            'statistics': ['portfolioStatistics_adjusted.csv', 'portfolioStatistics_adjusted_*.csv'],
            'optimize_stats': ['portfolioStatistics_optimize_adjusted.csv', 'portfolioStatistics_optimize_adjusted.csv_*.csv'],
            'baseline': ['portfolioResult_baseline.csv', 'portfolioResult_baseline.csv_*.csv']
        }
        
        for key, patterns in file_mappings.items():
            loaded = False
            for pattern in patterns:
                files = list(self.output_dir.glob(pattern))
                if files:
                    try:
                        # Sort by modification time, get most recent
                        files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
                        self.data[key] = pd.read_csv(files[0])
                        print(f"✓ Loaded {key}: {files[0].name}")
                        loaded = True
                        break
                    except Exception as e:
                        print(f"✗ Error loading {key} from {files[0].name}: {e}")
            
            if not loaded:
                print(f"⚠ Not found: {key} (tried: {', '.join(patterns)})")
        
        # Note: Daily report is now generated by Java optimizer
        # If daily_report was loaded from CSV, we don't need to generate it from baseline
        # If it's not available, try to generate from baseline as fallback
        if 'daily_report' not in self.data and 'baseline' in self.data:
            print("⚠ Daily report not found in CSV, generating from baseline trades...")
            self.data['daily_report'] = self._generate_daily_report_from_trades()
            if self.data['daily_report'] is not None:
                print(f"✓ Generated daily report from {len(self.data['baseline'])} trades")
    
    def _generate_daily_report_from_trades(self):
        """Generate daily performance report from individual trade data
        
        Note: The Balance column in the trade data represents per-strategy balance,
        not portfolio balance. We need to aggregate profits across all strategies
        and calculate cumulative portfolio balance.
        """
        if 'baseline' not in self.data:
            return None
        
        df = self.data['baseline'].copy()
        
        # Parse close time to datetime
        df['Close Time'] = pd.to_datetime(df['Close Time'], format='%d/%m/%Y %H:%M')
        df['Date'] = df['Close Time'].dt.date
        
        # Group by date and sum profits across all strategies
        daily = df.groupby('Date').agg({
            'Profit': 'sum',  # Sum all profits/losses for the day across all strategies
        }).reset_index()
        
        daily['Date'] = pd.to_datetime(daily['Date'])
        daily.rename(columns={'Profit': 'Daily Return'}, inplace=True)
        
        # Calculate cumulative balance starting from initial capital
        # Assuming starting balance of $100,000
        starting_balance = 100000
        daily['Balance'] = starting_balance + daily['Daily Return'].cumsum()
        
        # Calculate percentage return based on previous day's balance
        daily['Previous Balance'] = daily['Balance'] - daily['Daily Return']
        daily['Daily Return %'] = (daily['Daily Return'] / daily['Previous Balance']) * 100
        
        return daily
    
    def plot_best_portfolio_allocation(self, save_path=None):
        """Visualize the best portfolio strategy allocation"""
        if 'best_portfolio' not in self.data:
            print("Best portfolio data not available")
            return
        
        df = self.data['best_portfolio']
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))
        
        # Bar chart
        colors = plt.cm.Set3(np.linspace(0, 1, len(df)))
        bars = ax1.bar(df['StrategyID'].astype(str), df['Risk'], color=colors)
        ax1.set_xlabel('Strategy ID', fontweight='bold')
        ax1.set_ylabel('Risk Multiplier', fontweight='bold')
        ax1.set_title('Best Portfolio - Strategy Risk Allocation', fontsize=14, fontweight='bold')
        ax1.tick_params(axis='x', rotation=45)
        ax1.grid(axis='y', alpha=0.3)
        
        # Add value labels on bars
        for bar in bars:
            height = bar.get_height()
            ax1.text(bar.get_x() + bar.get_width()/2., height,
                    f'{height:.1f}',
                    ha='center', va='bottom', fontsize=9)
        
        # Pie chart
        wedges, texts, autotexts = ax2.pie(df['Risk'], 
                                            labels=df['StrategyID'].astype(str),
                                            autopct='%1.1f%%',
                                            colors=colors,
                                            startangle=90)
        ax2.set_title('Risk Distribution (%)', fontsize=14, fontweight='bold')
        
        # Make percentage text more readable
        for autotext in autotexts:
            autotext.set_color('white')
            autotext.set_fontweight('bold')
            autotext.set_fontsize(9)
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            print(f"Saved: {save_path}")
        else:
            plt.show()
        
        plt.close()
    
    def plot_monthly_performance(self, save_path=None):
        """Plot monthly returns and equity curve"""
        if 'monthly_report' not in self.data:
            print("Monthly report data not available")
            return
        
        df = self.data['monthly_report'].copy()
        
        # Convert date column to datetime
        df['Date'] = pd.to_datetime(df['Montly In Year'], format='%Y%m')
        
        # Calculate running max and drawdown
        df['RunningMax'] = df['Balance'].expanding().max()
        df['Drawdown'] = ((df['Balance'] - df['RunningMax']) / df['RunningMax'] * 100)
        
        fig, axes = plt.subplots(4, 1, figsize=(16, 14))
        
        # 1. Equity Curve
        ax1 = axes[0]
        ax1.plot(df['Date'], df['Balance'], linewidth=2, color='#2E86AB', marker='o', markersize=4, label='Balance')
        ax1.plot(df['Date'], df['RunningMax'], linewidth=1.5, color='#FF6B6B', linestyle='--', alpha=0.7, label='Peak Balance')
        ax1.axhline(y=0, color='red', linestyle='--', linewidth=1, alpha=0.7)
        ax1.fill_between(df['Date'], df['Balance'], 0, alpha=0.3, color='#2E86AB')
        ax1.set_title('Equity Curve - Monthly Balance', fontsize=14, fontweight='bold')
        ax1.set_ylabel('Balance ($)', fontweight='bold')
        ax1.grid(True, alpha=0.3)
        ax1.ticklabel_format(style='plain', axis='y')
        ax1.legend(loc='upper left')
        
        # Add annotations for max/min
        max_idx = df['Balance'].idxmax()
        min_idx = df['Balance'].idxmin()
        ax1.annotate(f'Max: ${df.loc[max_idx, "Balance"]:,.0f}',
                    xy=(df.loc[max_idx, 'Date'], df.loc[max_idx, 'Balance']),
                    xytext=(10, 10), textcoords='offset points',
                    bbox=dict(boxstyle='round,pad=0.5', fc='yellow', alpha=0.7),
                    arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))
        
        # 2. Drawdown Chart
        ax2 = axes[1]
        ax2.fill_between(df['Date'], df['Drawdown'], 0, color='red', alpha=0.5, label='Drawdown')
        ax2.plot(df['Date'], df['Drawdown'], linewidth=2, color='darkred', marker='o', markersize=3)
        ax2.axhline(y=0, color='black', linewidth=1)
        max_dd_idx = df['Drawdown'].idxmin()
        ax2.annotate(f'Max DD (Month-End): {df.loc[max_dd_idx, "Drawdown"]:.2f}%',
                    xy=(df.loc[max_dd_idx, 'Date'], df.loc[max_dd_idx, 'Drawdown']),
                    xytext=(10, -20), textcoords='offset points',
                    bbox=dict(boxstyle='round,pad=0.5', fc='orange', alpha=0.8),
                    arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))
        
        # Add note about drawdown calculation
        if 'statistics' in self.data and 'Max_DD' in self.data['statistics'].columns:
            intraday_dd = self.data['statistics']['Max_DD'].iloc[0]
            note_text = f'Note: Intraday Max DD = {intraday_dd:.2f}%\n(Lower because measured tick-by-tick)'
            ax2.text(0.02, 0.02, note_text, transform=ax2.transAxes,
                    fontsize=8, verticalalignment='bottom',
                    bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
        
        ax2.set_title('Drawdown from Peak (%) - Month-End Snapshots', fontsize=14, fontweight='bold')
        ax2.set_ylabel('Drawdown (%)', fontweight='bold')
        ax2.grid(True, alpha=0.3, axis='y')
        ax2.legend(loc='lower left')
        
        # 3. Monthly Returns
        ax3 = axes[2]
        colors = ['green' if x > 0 else 'red' for x in df['Monthly Return']]
        bars = ax3.bar(df['Date'], df['Monthly Return'], color=colors, alpha=0.7, width=20)
        ax3.axhline(y=0, color='black', linewidth=1)
        ax3.set_title('Monthly Returns ($)', fontsize=14, fontweight='bold')
        ax3.set_ylabel('Return ($)', fontweight='bold')
        ax3.grid(True, alpha=0.3, axis='y')
        ax3.ticklabel_format(style='plain', axis='y')
        
        # 4. Monthly Returns Percentage
        ax4 = axes[3]
        colors = ['green' if x > 0 else 'red' for x in df['Monthly Return %']]
        ax4.bar(df['Date'], df['Monthly Return %'] * 100, color=colors, alpha=0.7, width=20)
        ax4.axhline(y=0, color='black', linewidth=1)
        ax4.set_title('Monthly Returns (%)', fontsize=14, fontweight='bold')
        ax4.set_xlabel('Date', fontweight='bold')
        ax4.set_ylabel('Return (%)', fontweight='bold')
        ax4.grid(True, alpha=0.3, axis='y')
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            print(f"Saved: {save_path}")
        else:
            plt.show()
        
        plt.close()
    
    def plot_weekly_performance(self, save_path=None):
        """Plot weekly returns and performance metrics"""
        if 'weekly_report' not in self.data:
            print("Weekly report data not available")
            return
        
        df = self.data['weekly_report'].copy()
        
        # Convert YYYYWW format to datetime (assuming Monday as start of week)
        df['Year'] = df['Weekly In Year'].astype(str).str[:4].astype(int)
        df['Week'] = df['Weekly In Year'].astype(str).str[4:].astype(int)
        df['Date'] = pd.to_datetime(df['Year'].astype(str) + '-W' + df['Week'].astype(str) + '-1', format='%Y-W%W-%w')
        
        # Calculate running max and drawdown
        df['RunningMax'] = df['Balance'].expanding().max()
        df['Drawdown'] = ((df['Balance'] - df['RunningMax']) / df['RunningMax'] * 100)
        
        fig, axes = plt.subplots(3, 1, figsize=(16, 12))
        
        # 1. Weekly Equity Curve
        ax1 = axes[0]
        ax1.plot(df['Date'], df['Balance'], linewidth=1.5, color='#2E86AB', alpha=0.8, label='Balance')
        ax1.plot(df['Date'], df['RunningMax'], linewidth=1, color='#FF6B6B', linestyle='--', alpha=0.7, label='Peak Balance')
        ax1.fill_between(df['Date'], df['Balance'], 0, alpha=0.2, color='#2E86AB')
        ax1.set_title('Weekly Equity Curve', fontsize=14, fontweight='bold')
        ax1.set_ylabel('Balance ($)', fontweight='bold')
        ax1.grid(True, alpha=0.3)
        ax1.ticklabel_format(style='plain', axis='y')
        ax1.legend(loc='upper left')
        
        # 2. Weekly Drawdown
        ax2 = axes[1]
        ax2.fill_between(df['Date'], df['Drawdown'], 0, color='red', alpha=0.4)
        ax2.plot(df['Date'], df['Drawdown'], linewidth=1, color='darkred', alpha=0.8)
        ax2.axhline(y=0, color='black', linewidth=1)
        max_dd_idx = df['Drawdown'].idxmin()
        ax2.annotate(f'Max DD: {df.loc[max_dd_idx, "Drawdown"]:.2f}%',
                    xy=(df.loc[max_dd_idx, 'Date'], df.loc[max_dd_idx, 'Drawdown']),
                    xytext=(10, -15), textcoords='offset points',
                    bbox=dict(boxstyle='round,pad=0.5', fc='orange', alpha=0.8),
                    arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))
        ax2.set_title('Weekly Drawdown from Peak (%)', fontsize=14, fontweight='bold')
        ax2.set_ylabel('Drawdown (%)', fontweight='bold')
        ax2.grid(True, alpha=0.3, axis='y')
        
        # 3. Weekly Returns
        ax3 = axes[2]
        colors = ['green' if x > 0 else 'red' for x in df['Weekly Return']]
        ax3.bar(df['Date'], df['Weekly Return'], color=colors, alpha=0.7, width=5)
        ax3.axhline(y=0, color='black', linewidth=1)
        ax3.set_title('Weekly Returns ($)', fontsize=14, fontweight='bold')
        ax3.set_xlabel('Date', fontweight='bold')
        ax3.set_ylabel('Return ($)', fontweight='bold')
        ax3.grid(True, alpha=0.3, axis='y')
        ax3.ticklabel_format(style='plain', axis='y')
        
        # Add summary statistics
        positive_weeks = (df['Weekly Return'] > 0).sum()
        win_rate = positive_weeks / len(df) * 100
        avg_win = df[df['Weekly Return'] > 0]['Weekly Return'].mean()
        avg_loss = df[df['Weekly Return'] < 0]['Weekly Return'].mean()
        
        # Get statistics file Max_DD for comparison
        stats_dd_text = ""
        if 'statistics' in self.data:
            stats_dd = self.data['statistics']['Max_DD'].iloc[0]
            stats_dd_text = f"\nMax DD (intraday): {stats_dd:.2f}% (captures intraweek recoveries)"
        
        stats_text = f'Win Rate: {win_rate:.1f}% ({positive_weeks}/{len(df)} weeks)\n'
        stats_text += f'Avg Win: ${avg_win:,.0f} | Avg Loss: ${avg_loss:,.0f}{stats_dd_text}'
        ax3.text(0.02, 0.98, stats_text, transform=ax3.transAxes,
                fontsize=9, verticalalignment='top',
                bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.7))
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            print(f"Saved: {save_path}")
        else:
            plt.show()
        
        plt.close()
    
    def plot_daily_performance(self, save_path=None):
        """Plot daily returns and performance metrics"""
        if 'daily_report' not in self.data:
            print("Daily report data not available")
            return
        
        df = self.data['daily_report'].copy()
        
        # Handle date column - could be 'Date' (from Java) or generated from baseline
        if 'Date' in df.columns:
            # Java-generated CSV has Date in YYYYMMDD format
            df['Date'] = pd.to_datetime(df['Date'], format='%Y%m%d')
        
        # Rename columns to standardize (Java uses "Daily Return", Python generation also uses it)
        if 'Daily Return' not in df.columns and 'Profit' in df.columns:
            df.rename(columns={'Profit': 'Daily Return'}, inplace=True)
        
        # Calculate running max and drawdown
        df['RunningMax'] = df['Balance'].expanding().max()
        df['Drawdown'] = ((df['Balance'] - df['RunningMax']) / df['RunningMax'] * 100)
        
        fig, axes = plt.subplots(3, 1, figsize=(16, 12))
        
        # 1. Daily Equity Curve
        ax1 = axes[0]
        ax1.plot(df['Date'], df['Balance'], linewidth=0.8, color='#2E86AB', alpha=0.8, label='Balance')
        ax1.plot(df['Date'], df['RunningMax'], linewidth=0.8, color='#FF6B6B', linestyle='--', alpha=0.7, label='Peak Balance')
        ax1.fill_between(df['Date'], df['Balance'], 0, alpha=0.2, color='#2E86AB')
        ax1.set_title('Daily Equity Curve', fontsize=14, fontweight='bold')
        ax1.set_ylabel('Balance ($)', fontweight='bold')
        ax1.grid(True, alpha=0.3)
        ax1.ticklabel_format(style='plain', axis='y')
        ax1.legend(loc='upper left')
        
        # 2. Daily Drawdown
        ax2 = axes[1]
        ax2.fill_between(df['Date'], df['Drawdown'], 0, color='red', alpha=0.4)
        ax2.plot(df['Date'], df['Drawdown'], linewidth=0.8, color='darkred', alpha=0.8)
        ax2.axhline(y=0, color='black', linewidth=1)
        max_dd_idx = df['Drawdown'].idxmin()
        ax2.annotate(f'Max DD: {df.loc[max_dd_idx, "Drawdown"]:.2f}%',
                    xy=(df.loc[max_dd_idx, 'Date'], df.loc[max_dd_idx, 'Drawdown']),
                    xytext=(10, -15), textcoords='offset points',
                    bbox=dict(boxstyle='round,pad=0.5', fc='orange', alpha=0.8),
                    arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))
        ax2.set_title('Daily Drawdown from Peak (%)', fontsize=14, fontweight='bold')
        ax2.set_ylabel('Drawdown (%)', fontweight='bold')
        ax2.grid(True, alpha=0.3, axis='y')
        
        # 3. Daily Returns
        ax3 = axes[2]
        colors = ['green' if x > 0 else 'red' for x in df['Daily Return']]
        ax3.bar(df['Date'], df['Daily Return'], color=colors, alpha=0.7, width=1)
        ax3.axhline(y=0, color='black', linewidth=1)
        ax3.set_title('Daily Returns ($)', fontsize=14, fontweight='bold')
        ax3.set_xlabel('Date', fontweight='bold')
        ax3.set_ylabel('Return ($)', fontweight='bold')
        ax3.grid(True, alpha=0.3, axis='y')
        ax3.ticklabel_format(style='plain', axis='y')
        
        # Add summary statistics
        positive_days = (df['Daily Return'] > 0).sum()
        win_rate = positive_days / len(df) * 100
        avg_win = df[df['Daily Return'] > 0]['Daily Return'].mean()
        avg_loss = df[df['Daily Return'] < 0]['Daily Return'].mean()
        
        # Get statistics file Max_DD if available for comparison
        stats_dd_text = ""
        if 'statistics' in self.data:
            stats_dd = self.data['statistics']['Max_DD'].iloc[0]
            stats_dd_text = f"\\n\\nMax DD (intraday/trade-level): {stats_dd:.2f}%"
            stats_dd_text += "\\n(Lower because it captures intraday recoveries)"
        
        stats_text = f'Win Rate: {win_rate:.1f}% ({positive_days}/{len(df)} days)\\n'
        stats_text += f'Avg Win: ${avg_win:,.0f} | Avg Loss: ${avg_loss:,.0f}{stats_dd_text}'
        ax3.text(0.02, 0.98, stats_text, transform=ax3.transAxes,
                fontsize=8, verticalalignment='top',
                bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.7))
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            print(f"Saved: {save_path}")
        else:
            plt.show()
        
        plt.close()
    
    def plot_portfolio_statistics(self, save_path=None):
        """Compare portfolio statistics between baseline and optimized"""
        if 'optimize_stats' not in self.data:
            print("Optimization statistics data not available")
            return
        
        df = self.data['optimize_stats'].copy()
        
        # Get key metrics (first row is usually the best)
        if len(df) == 0:
            print("No data in optimization statistics")
            return
        
        # Select important metrics to display
        metrics_to_plot = {
            'Cagr': 'CAGR (%)',
            'Sharp_ratio': 'Sharpe Ratio',
            'Max_DD': 'Max Drawdown (%)',
            'Profit_factor': 'Profit Factor',
            'Martin': 'Martin Ratio',
            'UlcerIndex': 'Ulcer Index',
            'Winning': 'Win Rate (%)',
            'Risk_reward': 'Risk/Reward Ratio'
        }
        
        available_metrics = {k: v for k, v in metrics_to_plot.items() if k in df.columns}
        
        if not available_metrics:
            print("No plottable metrics found")
            return
        
        # Create subplots for top portfolios
        n_portfolios = min(5, len(df))
        fig, axes = plt.subplots(2, 4, figsize=(18, 10))
        axes = axes.flatten()
        
        for idx, (col, label) in enumerate(available_metrics.items()):
            if idx >= len(axes):
                break
            
            ax = axes[idx]
            values = df[col].head(n_portfolios).values
            portfolio_labels = [f'P{i+1}' for i in range(n_portfolios)]
            
            colors = plt.cm.viridis(np.linspace(0, 1, n_portfolios))
            bars = ax.bar(portfolio_labels, values, color=colors, alpha=0.8)
            
            ax.set_title(label, fontweight='bold')
            ax.set_ylabel('Value')
            ax.grid(axis='y', alpha=0.3)
            
            # Add value labels
            for bar in bars:
                height = bar.get_height()
                ax.text(bar.get_x() + bar.get_width()/2., height,
                       f'{height:.2f}',
                       ha='center', va='bottom', fontsize=9)
        
        # Hide unused subplots
        for idx in range(len(available_metrics), len(axes)):
            axes[idx].axis('off')
        
        fig.suptitle('Top 5 Portfolio Configurations - Performance Metrics', 
                     fontsize=16, fontweight='bold', y=1.00)
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            print(f"Saved: {save_path}")
        else:
            plt.show()
        
        plt.close()
    
    def plot_risk_return_scatter(self, save_path=None):
        """Create risk-return scatter plot of all evaluated portfolios"""
        if 'optimize_stats' not in self.data:
            print("Optimization statistics data not available")
            return
        
        df = self.data['optimize_stats'].copy()
        
        if 'Max_DD' not in df.columns or 'Cagr' not in df.columns:
            print("Required columns (Max_DD, Cagr) not found")
            return
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))
        
        # 1. Risk-Return Scatter (Max DD vs CAGR)
        scatter1 = ax1.scatter(df['Max_DD'], df['Cagr'], 
                              c=df['Martin'], cmap='RdYlGn',
                              s=100, alpha=0.6, edgecolors='black', linewidth=0.5)
        
        # Highlight best portfolio
        best_idx = df['Martin'].idxmax()
        ax1.scatter(df.loc[best_idx, 'Max_DD'], df.loc[best_idx, 'Cagr'],
                   s=500, c='gold', marker='*', edgecolors='black', linewidth=2,
                   label='Best Portfolio', zorder=5)
        
        ax1.set_xlabel('Max Drawdown (%)', fontweight='bold')
        ax1.set_ylabel('CAGR (%)', fontweight='bold')
        ax1.set_title('Risk-Return Profile (colored by Martin Ratio)', fontsize=14, fontweight='bold')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        cbar1 = plt.colorbar(scatter1, ax=ax1)
        cbar1.set_label('Martin Ratio', fontweight='bold')
        
        # 2. Ulcer Index vs Sharp Ratio
        if 'UlcerIndex' in df.columns and 'Sharp_ratio' in df.columns:
            scatter2 = ax2.scatter(df['UlcerIndex'], df['Sharp_ratio'],
                                  c=df['Profit_factor'], cmap='plasma',
                                  s=100, alpha=0.6, edgecolors='black', linewidth=0.5)
            
            ax2.scatter(df.loc[best_idx, 'UlcerIndex'], df.loc[best_idx, 'Sharp_ratio'],
                       s=500, c='gold', marker='*', edgecolors='black', linewidth=2,
                       label='Best Portfolio', zorder=5)
            
            ax2.set_xlabel('Ulcer Index', fontweight='bold')
            ax2.set_ylabel('Sharpe Ratio', fontweight='bold')
            ax2.set_title('Risk-Adjusted Performance (colored by Profit Factor)', 
                         fontsize=14, fontweight='bold')
            ax2.legend()
            ax2.grid(True, alpha=0.3)
            
            cbar2 = plt.colorbar(scatter2, ax=ax2)
            cbar2.set_label('Profit Factor', fontweight='bold')
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            print(f"Saved: {save_path}")
        else:
            plt.show()
        
        plt.close()
    
    def generate_summary_report(self, save_path=None):
        """Generate a text summary report"""
        lines = []
        lines.append("="*80)
        lines.append("PORTFOLIO OPTIMIZATION SUMMARY REPORT")
        lines.append("="*80)
        lines.append("")
        
        # Best Portfolio
        if 'best_portfolio' in self.data:
            lines.append("BEST PORTFOLIO ALLOCATION:")
            lines.append("-" * 40)
            df = self.data['best_portfolio']
            for _, row in df.iterrows():
                lines.append(f"  Strategy {row['StrategyID']}: {row['Risk']:.2f}x")
            lines.append(f"  Total Risk: {df['Risk'].sum():.2f}")
            lines.append("")
        
        # Performance Metrics
        if 'optimize_stats' in self.data:
            lines.append("PERFORMANCE METRICS (Best Portfolio):")
            lines.append("-" * 40)
            df = self.data['optimize_stats']
            if len(df) > 0:
                best = df.iloc[0]
                metrics = {
                    'CAGR': f"{best.get('Cagr', 0):.2f}%",
                    'Max Drawdown': f"{best.get('Max_DD', 0):.2f}%",
                    'Sharpe Ratio': f"{best.get('Sharp_ratio', 0):.3f}",
                    'Martin Ratio': f"{best.get('Martin', 0):.2f}",
                    'Ulcer Index': f"{best.get('UlcerIndex', 0):.2f}",
                    'Profit Factor': f"{best.get('Profit_factor', 0):.3f}",
                    'Win Rate': f"{best.get('Winning', 0):.2f}%",
                    'Risk/Reward': f"{best.get('Risk_reward', 0):.3f}",
                    'Total Trades': f"{best.get('Num_trades', 0):.0f}",
                    'Best Trade': f"${best.get('BestTrade', 0):,.2f}",
                    'Worst Trade': f"${best.get('WorstTrade', 0):,.2f}",
                }
                
                for key, value in metrics.items():
                    lines.append(f"  {key:<20}: {value}")
            lines.append("")
        
        # Monthly Performance Summary
        if 'monthly_report' in self.data:
            lines.append("MONTHLY PERFORMANCE SUMMARY:")
            lines.append("-" * 40)
            df = self.data['monthly_report']
            lines.append(f"  Total Months: {len(df)}")
            lines.append(f"  Final Balance: ${df['Balance'].iloc[-1]:,.2f}")
            lines.append(f"  Peak Balance: ${df['Balance'].max():,.2f}")
            lines.append(f"  Lowest Balance: ${df['Balance'].min():,.2f}")
            
            positive_months = (df['Monthly Return'] > 0).sum()
            lines.append(f"  Positive Months: {positive_months}/{len(df)} ({positive_months/len(df)*100:.1f}%)")
            
            avg_return = df['Monthly Return'].mean()
            lines.append(f"  Avg Monthly Return: ${avg_return:,.2f}")
            lines.append("")
        
        lines.append("="*80)
        
        report_text = "\n".join(lines)
        
        if save_path:
            with open(save_path, 'w') as f:
                f.write(report_text)
            print(f"Saved: {save_path}")
        else:
            print(report_text)
        
        return report_text
    
    def generate_all_visualizations(self, output_folder=None):
        """Generate all available visualizations"""
        if output_folder is None:
            output_folder = self.output_dir / "visualizations"
        else:
            output_folder = Path(output_folder)
        
        output_folder.mkdir(exist_ok=True)
        print(f"\nGenerating visualizations in: {output_folder}")
        print("="*80)
        
        # Generate each visualization
        print("\n1. Portfolio Allocation...")
        self.plot_best_portfolio_allocation(
            save_path=output_folder / "01_portfolio_allocation.png"
        )
        
        print("\n2. Monthly Performance...")
        self.plot_monthly_performance(
            save_path=output_folder / "02_monthly_performance.png"
        )
        
        print("\n3. Weekly Performance...")
        self.plot_weekly_performance(
            save_path=output_folder / "03_weekly_performance.png"
        )
        
        print("\n4. Daily Performance...")
        self.plot_daily_performance(
            save_path=output_folder / "04_daily_performance.png"
        )
        
        print("\n5. Portfolio Statistics...")
        self.plot_portfolio_statistics(
            save_path=output_folder / "05_portfolio_statistics.png"
        )
        
        print("\n6. Risk-Return Analysis...")
        self.plot_risk_return_scatter(
            save_path=output_folder / "06_risk_return_analysis.png"
        )
        
        print("\n7. Summary Report...")
        self.generate_summary_report(
            save_path=output_folder / "00_summary_report.txt"
        )
        
        print("\n" + "="*80)
        print(f"✓ All visualizations completed!")
        print(f"✓ Output directory: {output_folder.absolute()}")
        print("="*80)


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Visualize Portfolio Optimization Results',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Visualize latest optimizer output
  python visualize_portfolio.py batch/output/optimizer_20251130_233337
  
  # Specify custom output folder for visualizations
  python visualize_portfolio.py batch/output/optimizer_20251130_233337 -o my_charts
        """
    )
    
    parser.add_argument('input_dir', 
                       help='Path to optimizer output directory')
    parser.add_argument('-o', '--output', 
                       help='Output folder for visualizations (default: input_dir/visualizations)',
                       default=None)
    
    args = parser.parse_args()
    
    # Validate input directory
    input_path = Path(args.input_dir)
    if not input_path.exists():
        print(f"Error: Directory not found: {input_path}")
        sys.exit(1)
    
    # Create visualizer and generate all charts
    visualizer = PortfolioVisualizer(input_path)
    visualizer.generate_all_visualizations(output_folder=args.output)


if __name__ == '__main__':
    main()
