#!/usr/bin/env pwsh
<#
.SYNOPSIS
Universal build orchestration script for AsirikuyFramework
Handles multi-configuration builds with organized output directories

.DESCRIPTION
Coordinates all build processes:
- Project folder builds (in-place compilation)
- Centralized bin folder organization
- Release package generation
- Multi-platform support (Windows/macOS/Linux)

.PARAMETER Action
Action to perform: build, clean, release, test, all (default: all)

.PARAMETER Configuration
Configuration: debug32, debug64, release32, release64, or "all"

.PARAMETER AllConfigs
Build all configurations (Debug/Release × x32/x64)

.PARAMETER Parallel
Enable parallel builds (speeds up multi-config builds)

.PARAMETER OutputLayout
Output organization: flat, structured, both (default: structured)
- flat: bin/AsirikuyFrameworkAPI.dll, bin/trading_strategies.lib
- structured: bin/Release/x64/AsirikuyFrameworkAPI.dll
- both: both layouts in bin/

.PARAMETER ReleaseOutput
Output directory for release packages (default: ./releases)

.PARAMETER NoCleanup
Don't clean old artifacts before building

.EXAMPLE
# Standard release build with structured output
.\build-orchestrate.ps1 -Action build -Configuration release64 -OutputLayout structured

# Build all configurations in parallel with release package
.\build-orchestrate.ps1 -AllConfigs -Parallel -Action release

# Clean and rebuild everything
.\build-orchestrate.ps1 -Action clean -AllConfigs
.\build-orchestrate.ps1 -Action build -AllConfigs
#>

param(
    [ValidateSet("build", "clean", "release", "test", "all")]
    [string]$Action = "all",
    
    [string]$Configuration = "release64",
    [switch]$AllConfigs,
    [switch]$Parallel,
    
    [ValidateSet("flat", "structured", "both")]
    [string]$OutputLayout = "structured",
    
    [string]$ReleaseOutput = "./releases",
    [switch]$NoCleanup,
    [switch]$Verbose,
    [switch]$Help
)

# ============================================================================
# CONSTANTS & CONFIGURATION
# ============================================================================

$ErrorActionPreference = "Stop"
$ProgressPreference = "SilentlyContinue"

$SCRIPT_DIR = Split-Path -Parent $MyInvocation.MyCommand.Path
$REPO_ROOT = $SCRIPT_DIR

# Standard output directory structure
$OUTPUT_BASE = Join-Path $REPO_ROOT "bin"
$ARTIFACTS_DIR = Join-Path $REPO_ROOT "artifacts"

# Build directory (generated by premake)
$BUILD_DIR = Join-Path $REPO_ROOT "build\vs2010"

# Logging
$TIMESTAMP = Get-Date -Format "yyyyMMdd-HHmmss"
$LOG_FILE = Join-Path $REPO_ROOT "build-${TIMESTAMP}.log"

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

function Write-Log {
    param([string]$Message, [ValidateSet("INFO", "SUCCESS", "WARN", "ERROR")]$Level = "INFO")
    
    $time = Get-Date -Format "HH:mm:ss"
    $color = @{
        INFO    = "Cyan"
        SUCCESS = "Green"
        WARN    = "Yellow"
        ERROR   = "Red"
    }[$Level]
    
    $prefix = @{
        INFO    = "[INFO] "
        SUCCESS = "[OK]   "
        WARN    = "[!]    "
        ERROR   = "[XX]   "
    }[$Level]
    
    $msg = "$time $prefix$Message"
    Write-Host $msg -ForegroundColor $color
    Add-Content -LiteralPath $LOG_FILE -Value $msg
}

function Show-Help {
    Get-Help $PSCommandPath -Detailed
}

function Test-Prerequisites {
    Write-Log "Checking prerequisites..." "INFO"
    
    $issues = @()
    
    # Check MSBuild
    $msbuild = Get-Command msbuild.exe -ErrorAction SilentlyContinue
    if ($null -eq $msbuild) {
        $msbuild = @(
            "C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin\MSBuild.exe",
            "C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\MSBuild.exe"
        ) | Where-Object { Test-Path $_ } | Select-Object -First 1
    } else {
        $msbuild = $msbuild.Source
    }
    
    if (-not $msbuild) {
        $issues += "MSBuild not found"
    } else {
        Write-Log "Found MSBuild: $msbuild" "SUCCESS"
    }
    
    # Check premake
    $premake = Join-Path $REPO_ROOT "premake4.exe"
    if (-not (Test-Path $premake)) {
        $issues += "premake4.exe not found"
    } else {
        Write-Log "Found premake4" "SUCCESS"
    }
    
    # Check BOOST_ROOT
    if (-not $env:BOOST_ROOT) {
        Write-Log "BOOST_ROOT not set" "WARN"
    } else {
        Write-Log "BOOST_ROOT: $env:BOOST_ROOT" "SUCCESS"
    }
    
    if ($issues.Count -gt 0) {
        foreach ($issue in $issues) {
            Write-Log "  ✗ $issue" "ERROR"
        }
        return $false
    }
    
    Write-Log "All prerequisites met" "SUCCESS"
    return $true
}

function Get-ConfigurationMatrix {
    if ($AllConfigs) {
        @(
            @{Config = "debug32"; Name = "Debug (x32)"; Type = "Debug"; Platform = "Win32" },
            @{Config = "debug64"; Name = "Debug (x64)"; Type = "Debug"; Platform = "x64" },
            @{Config = "release32"; Name = "Release (x32)"; Type = "Release"; Platform = "Win32" },
            @{Config = "release64"; Name = "Release (x64)"; Type = "Release"; Platform = "x64" }
        )
    } else {
        $type = if ($Configuration.StartsWith("debug")) { "Debug" } else { "Release" }
        $plat = if ($Configuration.EndsWith("64")) { "x64" } else { "Win32" }
        @(@{Config = $Configuration; Name = $Configuration; Type = $type; Platform = $plat })
    }
}

function Invoke-Clean {
    Write-Log "=========================================================================" "INFO"
    Write-Log "CLEAN PHASE" "INFO"
    Write-Log "=========================================================================" "INFO"
    
    if ($NoCleanup) {
        Write-Log "Cleanup skipped (-NoCleanup)" "WARN"
        return $true
    }
    
    $dirToClean = @(
        "build\vs2010",
        "bin\vs2010",
        "tmp\vs2010",
        $OUTPUT_BASE,
        $ARTIFACTS_DIR
    )
    
    foreach ($dir in $dirToClean) {
        $path = Join-Path $REPO_ROOT $dir
        if (Test-Path $path) {
            Write-Log "Removing: $dir" "INFO"
            Remove-Item -LiteralPath $path -Recurse -Force -ErrorAction SilentlyContinue
        }
    }
    
    Write-Log "Clean completed" "SUCCESS"
    return $true
}

function Invoke-Premake {
    Write-Log "Initializing premake4..." "INFO"
    
    $premake = Join-Path $REPO_ROOT "premake4.exe"
    $premakeArgs = @("--file=premake4.lua", "vs2010")
    
    Push-Location $REPO_ROOT
    & $premake @premakeArgs 2>&1 | Tee-Object -Append -FilePath $LOG_FILE | Write-Host
    $result = $LASTEXITCODE
    Pop-Location
    
    if ($result -ne 0) {
        Write-Log "premake4 failed with exit code $result" "ERROR"
        return $false
    }
    
    Write-Log "premake4 completed" "SUCCESS"
    return $true
}

function Invoke-BuildConfig {
    param(
        [string]$Configuration,
        [string]$Platform
    )
    
    Write-Log "Building: $Configuration (Platform: $Platform)" "INFO"
    
    $slnPath = Join-Path $REPO_ROOT "build\vs2010\AsirikuyFramework.sln"
    if (-not (Test-Path $slnPath)) {
        Write-Log "Solution not found: $slnPath" "ERROR"
        return $false
    }
    
    $msbuild = Get-Command msbuild.exe -ErrorAction SilentlyContinue
    if ($null -eq $msbuild) {
        $msbuild = @(
            "C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin\MSBuild.exe",
            "C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\MSBuild.exe"
        ) | Where-Object { Test-Path $_ } | Select-Object -First 1
    } else {
        $msbuild = $msbuild.Source
    }
    
    if (-not $msbuild) {
        Write-Log "MSBuild not found" "ERROR"
        return $false
    }
    
    $verbosity = if ($Verbose) { "normal" } else { "minimal" }
    
    $args = @(
        $slnPath,
        "/m",
        "/p:Configuration=$Configuration",
        "/p:Platform=$Platform",
        "/p:TrackFileAccess=false",
        "/v:$verbosity",
        "/nodeReuse:true"
    )
    
    if ($Verbose) {
        Write-Log "Command: `"$msbuild`" $($args -join ' ')" "INFO"
    }
    
    & $msbuild @args 2>&1 | Tee-Object -Append -FilePath $LOG_FILE | Write-Host
    
    if ($LASTEXITCODE -ne 0) {
        Write-Log "Build failed" "ERROR"
        return $false
    }
    
    Write-Log "Build succeeded" "SUCCESS"
    return $true
}

function Invoke-Build {
    Write-Log "=========================================================================" "INFO"
    Write-Log "BUILD PHASE" "INFO"
    Write-Log "=========================================================================" "INFO"
    
    if (-not (Invoke-Premake)) {
        return $false
    }
    
    $configs = Get-ConfigurationMatrix
    $results = @()
    
    foreach ($cfg in $configs) {
        $success = Invoke-BuildConfig -Configuration $cfg.Type -Platform $cfg.Platform
        $results += @{ Config = $cfg.Config; Success = $success }
        
        if (-not $success -and -not $Parallel) {
            Write-Log "Stopping due to build failure" "WARN"
            break
        }
    }
    
    $successCount = ($results | Where-Object { $_.Success } | Measure-Object).Count
    $totalCount = $results.Count
    
    Write-Log "Build Results: $successCount/$totalCount successful" "INFO"
    
    return ($successCount -eq $totalCount)
}

function Invoke-Organize {
    Write-Log "=========================================================================" "INFO"
    Write-Log "ORGANIZE OUTPUT PHASE" "INFO"
    Write-Log "=========================================================================" "INFO"
    
    New-Item -ItemType Directory -Path $OUTPUT_BASE -Force | Out-Null
    
    $srcDir = Join-Path $REPO_ROOT "bin\vs2010"
    if (-not (Test-Path $srcDir)) {
        Write-Log "No artifacts found at: $srcDir" "WARN"
        return $true
    }
    
    # Copy based on layout preference
    switch ($OutputLayout) {
        "flat" {
            Write-Log "Organizing artifacts in flat layout..." "INFO"
            Get-ChildItem -Recurse -Path $srcDir -File -Include @("*.dll", "*.lib", "*.exe") |
                ForEach-Object {
                    Copy-Item $_.FullName (Join-Path $OUTPUT_BASE $_.Name) -Force
                    Write-Log "  Copied: $($_.Name)" "INFO"
                }
        }
        "structured" {
            Write-Log "Organizing artifacts in structured layout..." "INFO"
            Get-ChildItem -Recurse -Path $srcDir -File -Include @("*.dll", "*.lib", "*.exe") |
                ForEach-Object {
                    $relPath = $_.DirectoryName.Substring($srcDir.Length).TrimStart('\')
                    $destDir = Join-Path $OUTPUT_BASE $relPath
                    New-Item -ItemType Directory -Path $destDir -Force | Out-Null
                    Copy-Item $_.FullName (Join-Path $destDir $_.Name) -Force
                    Write-Log "  Copied: $relPath\$($_.Name)" "INFO"
                }
        }
        "both" {
            Write-Log "Organizing artifacts in both layouts..." "INFO"
            # Flat
            Get-ChildItem -Recurse -Path $srcDir -File -Include @("*.dll", "*.lib", "*.exe") |
                ForEach-Object {
                    Copy-Item $_.FullName (Join-Path $OUTPUT_BASE $_.Name) -Force
                }
            # Structured (under subdirectory)
            $structDir = Join-Path $OUTPUT_BASE "structured"
            Get-ChildItem -Recurse -Path $srcDir -File -Include @("*.dll", "*.lib", "*.exe") |
                ForEach-Object {
                    $relPath = $_.DirectoryName.Substring($srcDir.Length).TrimStart('\')
                    $destDir = Join-Path $structDir $relPath
                    New-Item -ItemType Directory -Path $destDir -Force | Out-Null
                    Copy-Item $_.FullName (Join-Path $destDir $_.Name) -Force
                }
        }
    }
    
    Write-Log "Artifacts organized in: $OUTPUT_BASE" "SUCCESS"
    return $true
}

function Invoke-Release {
    Write-Log "=========================================================================" "INFO"
    Write-Log "RELEASE PHASE" "INFO"
    Write-Log "=========================================================================" "INFO"
    
    if (-not (Invoke-Build)) {
        Write-Log "Build phase failed, skipping release" "WARN"
        return $false
    }
    
    if (-not (Invoke-Organize)) {
        Write-Log "Organize phase failed" "ERROR"
        return $false
    }
    
    # Create release package
    New-Item -ItemType Directory -Path $ReleaseOutput -Force | Out-Null
    
    $releaseName = "AsirikuyFramework-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
    $releaseDir = Join-Path $ReleaseOutput $releaseName
    
    $subdirs = @("bin", "lib", "include", "docs", "licenses")
    foreach ($subdir in $subdirs) {
        New-Item -ItemType Directory -Path (Join-Path $releaseDir $subdir) -Force | Out-Null
    }
    
    # Copy DLLs
    Get-ChildItem -Recurse -Path $OUTPUT_BASE -File -Include "*.dll" -ErrorAction SilentlyContinue |
        ForEach-Object {
            Copy-Item $_.FullName (Join-Path $releaseDir "bin") -Force
            Write-Log "  Packaged: $($_.Name)" "INFO"
        }
    
    # Copy LIBs
    Get-ChildItem -Recurse -Path $OUTPUT_BASE -File -Include "*.lib" -ErrorAction SilentlyContinue |
        ForEach-Object {
            Copy-Item $_.FullName (Join-Path $releaseDir "lib") -Force
            Write-Log "  Packaged: $($_.Name)" "INFO"
        }
    
    # Copy headers
    if (Test-Path "core") {
        Get-ChildItem -Recurse -Path "core" -Directory -Filter "include" -ErrorAction SilentlyContinue |
            ForEach-Object {
                $parent = $_.Parent.Name
                Copy-Item $_.FullName (Join-Path $releaseDir "include" $parent) -Recurse -Force -ErrorAction SilentlyContinue
                Write-Log "  Packaged headers: $parent" "INFO"
            }
    }
    
    # Copy docs
    Get-ChildItem -Path "docs" -File -Include "*.md" -ErrorAction SilentlyContinue |
        ForEach-Object {
            Copy-Item $_.FullName (Join-Path $releaseDir "docs") -Force
            Write-Log "  Packaged: $($_.Name)" "INFO"
        }
    
    # Create release manifest
    $manifest = @{
        Release = $releaseName
        Date = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        Platform = "Windows"
        Configurations = (Get-ConfigurationMatrix | ForEach-Object { $_.Config })
    } | ConvertTo-Json -Depth 3
    
    $manifest | Set-Content (Join-Path $releaseDir "MANIFEST.json")
    
    Write-Log "Release package created: $releaseDir" "SUCCESS"
    
    return $true
}

function Invoke-Test {
    Write-Log "=========================================================================" "INFO"
    Write-Log "TEST PHASE" "INFO"
    Write-Log "=========================================================================" "INFO"
    
    Write-Log "Verifying build artifacts..." "INFO"
    
    if (-not (Test-Path $OUTPUT_BASE)) {
        Write-Log "Output directory not found: $OUTPUT_BASE" "ERROR"
        return $false
    }
    
    $artifacts = @(Get-ChildItem -Recurse -Path $OUTPUT_BASE -File -Include @("*.dll", "*.lib", "*.exe"))
    
    Write-Log "Found $($artifacts.Count) artifacts:" "INFO"
    
    $totalSize = 0
    foreach ($artifact in $artifacts) {
        $size = $artifact.Length
        $sizeKB = [math]::Round($size / 1KB, 2)
        $totalSize += $size
        Write-Log "  [Package] $($artifact.Name) ($sizeKB KB)" "INFO"
    }
    
    $totalSizeMB = [math]::Round($totalSize / 1MB, 2)
    Write-Log "Total size: $totalSizeMB MB" "SUCCESS"
    
    return $true
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if ($Help) {
    Show-Help
    exit 0
}

# Create log file
New-Item -ItemType File -Path $LOG_FILE -Force | Out-Null

Write-Log "=========================================================================" "INFO"
Write-Log "AsirikuyFramework Build Orchestration" "INFO"
Write-Log "=========================================================================" "INFO"
Write-Log "Repository: $REPO_ROOT" "INFO"
Write-Log "Action: $Action" "INFO"
Write-Log "All Configs: $AllConfigs" "INFO"
Write-Log "Output Layout: $OutputLayout" "INFO"
Write-Log "Log File: $LOG_FILE" "INFO"

# Check prerequisites
if (-not (Test-Prerequisites)) {
    Write-Log "Prerequisites check failed" "ERROR"
    exit 1
}

# Execute action
$success = $true

switch ($Action) {
    "clean" {
        $success = Invoke-Clean
    }
    "build" {
        $success = (Invoke-Clean) -and (Invoke-Build) -and (Invoke-Organize)
    }
    "release" {
        $success = Invoke-Release
    }
    "test" {
        $success = Invoke-Test
    }
    "all" {
        $success = (Invoke-Clean) -and (Invoke-Build) -and (Invoke-Organize) -and (Invoke-Release) -and (Invoke-Test)
    }
}

Write-Log "=========================================================================" "INFO"
Write-Log "Orchestration Complete" "INFO"
Write-Log "=========================================================================" "INFO"
Write-Log "Log file: $LOG_FILE" "INFO"

if ($success) {
    Write-Log "Status: SUCCESS" "SUCCESS"
    exit 0
} else {
    Write-Log "Status: FAILED" "ERROR"
    exit 1
}
